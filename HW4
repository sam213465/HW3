// 11327207 呂強 & 11327209 鄭育昇
#include <iostream>
#include <fstream>
#include <sstream>
#include <string>
#include <vector>
#include <ctime>
#include <cmath>
#include <iomanip>
using namespace std;

struct Node {
  int oid;
  int arrival;
  int duration;
  int timeout;
  Node *next;
};

class Queue {
 private:
   Node * backptr {nullptr};
   Node * frontptr {nullptr};
   int size = 0;
 public:
  bool Isempty() {
    if (backptr == nullptr) {
      return true;
    }
    return false;
  }

  void Enqueue(int o, int a, int d, int t) {
    Node *newptr = new Node;
    newptr->oid = o;
    newptr->arrival = a;
    newptr->duration = d;
    newptr->timeout = t;
    newptr->next = nullptr;

    if (Isempty()) {
      frontptr = newptr;
    } else {
      backptr->next = newptr;
    }
    backptr = newptr;
    size++;
  }

  void Dequeue() {
    if (Isempty()) {
      return;
    }
    Node *temp = frontptr;
    if (frontptr == backptr) {
      frontptr = nullptr;
      backptr = nullptr;
    } else {
      frontptr = frontptr->next;
    }
    temp->next = nullptr;
    delete temp;
    size--;
  }

  int Getsize() {
    return size;
  }

  void Getfront(int &o, int &a, int &d, int &t) {
    if (Isempty()) {
      return;
    }
    o = frontptr->oid;
    a = frontptr->arrival;
    d = frontptr->duration;
    t = frontptr->timeout;
  }
};

// 檢查字串是否全為數字
bool Checkstring(string str) {
  if (str.length() == 0) {
    return false;
  }
  for (int i = 0; i < str.size(); i++) {
    if (i == 0 && str[i] == '-') {
      continue;
    }
    if (str[i] < '0' || str[i] > '9') {
      return false;
    }
  }
  return true;
}

class Data {
 private:
  int column = 0;
  int row = 0;
  vector<vector<string>> data;
  vector<vector<int>> intdata;
 public:
  double Read(string filename) {
    clock_t start, end;
    start = clock();

    ifstream fin(filename);
    if (!fin.is_open()) {
      cout << filename << " does not exist!\n";
      return -1;
    }

    string line;

    while (getline(fin, line)) {
    if (line.empty()) continue; // 跳過空行

    stringstream ss(line);
    string value;
    vector<string> row;
    while (ss >> value) {
      row.push_back(value);
    }
    data.push_back(row);
  }
    end = clock();
    double time = double(end - start) / 1000;
    fin.close();
    return time;
  }

  void Print() {
    cout << "\t";
    for (int i = 0; i < data.size(); i++) {
      for (int j = 0; j < data[i].size(); j++) {
          if (j <= 2) {
            cout << data[i][j] << "\t";
          } else {
            cout << data[i][j];
          }
        }
        cout << endl;
      if (i+1 < data.size()) {
        cout << "(" << i+1 << ") \t";
      }
    }
  }

  void Stringtoint() {
    intdata.resize(data.size()-1);
    for (int i = 1; i < data.size(); i++) {
      intdata[i-1].resize(data[i].size());
      for (int j = 0; j < data[i].size(); j++) {
        intdata[i-1][j] = stoi(data[i][j]);
      }
    }
  }

  double shellSort() {
    clock_t start, end;
    start = clock();
    int n = intdata.size();
    for (int h = intdata.size()/2; h > 0; h = h/2) {
      for (int unsorted = h; unsorted < n; ++unsorted) {
        vector<int> temp = intdata[unsorted];
        int j = unsorted;
        while (j >= h && intdata[j - h][1] >= temp[1]) {
          if (intdata[j-h][1] == temp[1]) {
            if (intdata[j-h][0] > temp[0]) {
              intdata[j] = intdata[j - h];
            } else {
              j -= h;
              continue;
            }
          } else {
            intdata[j] = intdata[j - h];   // 移動整行
          }
          j -= h;
          intdata[j] = temp;
        }
      }
    }
    end = clock();
    double time = double(end - start) / 1000;
    return time;
  }

  double WriteFile(string filename) {
    clock_t start, end;
    start = clock();
    ofstream fout(filename);

    if (!fout.is_open()) {
        cout << "Cannot open file!" << endl;
        return 0;
    }
    fout << "OID\tArrival\tDuration\tTimeOut" << endl;
    for (int i = 0; i < intdata.size(); i++) {
        for (int j = 0; j < intdata[i].size(); j++) {
            fout << intdata[i][j];
            if (j != intdata[i].size() - 1) fout << "\t"; // 每個數字用空格隔開
        }
        fout << "\n"; // 換行
    }
    end = clock();
    double time = double(end - start) / 1000;
    fout.close();
    return time;
}

  void Clean() {
    data.clear();
    intdata.clear();
  }

  void One(string filename) {
    Queue q;
    ofstream fout(filename);
    if (!fout.is_open()) {
      cout << "Cannot open file!" << endl;
      return;
    }
    int done = 0;
    int n = intdata.size();
    int index = 0;
    int idleTime = 0;
    vector<vector<int>> AbortList;
    vector<vector<int>> TimeoutList;

    while (index < n || !q.Isempty()) {

      if (q.Isempty() && index < n && idleTime < intdata[index][1]) idleTime = intdata[index][1];
        
      while (index < n && intdata[index][1] < idleTime) {
        int oid = intdata[index][0];
        int arr = intdata[index][1];
        int dur = intdata[index][2];
        int tol = intdata[index][3];

        if (q.Getsize() < 3) {
          q.Enqueue(oid, arr, dur, tol);
          cout << oid << " " << arr << " " << dur << " " << tol << "->inqueue" << endl;
        } else {
          cout << oid << " " << "0 0 " << arr << "-> abort" << endl;// queue 滿 → abort
          AbortList.push_back({oid, 0, 0, arr});
        }
        index++;
      }

      if (q.Isempty()) {
        if (index < n && intdata[index][1] == idleTime) {
          int oid = intdata[index][0];
          int arr = intdata[index][1];
          int dur = intdata[index][2];
          int tol = intdata[index][3];

          cout << oid << " " << arr << " " << dur << " " << tol << "-> direct start (Q empty)" << endl;

          int startTime = idleTime;
          int finishTime = startTime + dur;
          if (finishTime > tol) {
            int delay = startTime - arr;
            TimeoutList.push_back({oid, 1, delay, finishTime});
          }

          idleTime = finishTime;
          index++;
          continue;
        } else {
          continue;
        }

      }
      int oid, arrival, duration, timeout;
      q.Getfront(oid, arrival, duration, timeout);
      cout << oid << " " << arrival << " " << duration << " " << timeout << "-> dequeue" << endl;
      q.Dequeue();


      if (timeout < idleTime) {
        int abortTime = idleTime;
        int delay = abortTime - arrival;
        AbortList.push_back({oid, 1, delay, abortTime});
        continue;
      }


      int startTime = idleTime;
      int finishTime = startTime + duration;


      if (finishTime > timeout) {
        int delay = startTime - arrival;
        TimeoutList.push_back({oid, 1, delay, finishTime});
      }

      idleTime = finishTime;
      done++;

    }


    fout << "\t[Abort List]\n";
    fout << "\tOID\tCID\tDelay\tAbort\n";
    int i = 1;
    for (auto &v : AbortList) {
      fout << "["<< i << "]\t" << v[0] << "\t" << v[1] << "\t" << v[2] << "\t" << v[3] << "\n";
      i++;
    }

    fout << "\t[Timeout List]\n";
    fout << "\tOID\tCID\tDelay\tDeparture\n";
    i = 1;
    for (auto &v : TimeoutList) {
      fout << "["<< i << "]\t" << v[0] << "\t" << v[1] << "\t" << v[2] << "\t" << v[3] << "\n";
      i++;
    }


    long long totalDelay = 0;
    for (auto &v : AbortList) totalDelay += v[2];
    for (auto &v : TimeoutList) totalDelay += v[2];

    fout << "[Total Delay]\n" << totalDelay << " min.\n";
    double failurePercentage = (double)(AbortList.size() + TimeoutList.size()) / n * 100.0;
    fout << "[Failure Percentage]\n" << fixed << setprecision(2) << failurePercentage << " %" << "\n";
  }

  void Two(const string &outfilename) {
    int n = intdata.size();
    Queue q1, q2;
    int idle1 = 0, idle2 = 0;
    int idx = 0;

    vector<vector<int>> AbortList;   // {OID, CID, Delay, AbortTime}
    vector<vector<int>> TimeoutList; // {OID, CID, Delay, DepartureTime}

    // 主迴圈：逐筆到達處理
    while (idx < n) {
      int oid = intdata[idx][0];
      int arrival = intdata[idx][1];
      int duration = intdata[idx][2];
      int timeout = intdata[idx][3];

      // 忽略不合法資料
      if (duration <= 0 || arrival + duration > timeout) {
        idx++;
        continue;
      }

      // 處理 chef1 的佇列直到 idle1 > arrival 或佇列空
      while (!q1.Isempty() && idle1 <= arrival) {
        int fo, fa, fd, ft;
        q1.Getfront(fo, fa, fd, ft);
        if (ft < idle1) {
          int abortTime = idle1;
          int delay = abortTime - fa;
          AbortList.push_back(vector<int>{fo, 1, delay, abortTime});
          q1.Dequeue();
          continue;
        }
        int start = idle1;
        int finish = start + fd;
        if (finish > ft) {
          int delay = start - fa;
          TimeoutList.push_back(vector<int>{fo, 1, delay, finish});
        }
        idle1 = finish;
        q1.Dequeue();
      }

      // 處理 chef2 的佇列直到 idle2 > arrival 或佇列空
      while (!q2.Isempty() && idle2 <= arrival) {
        int fo, fa, fd, ft;
        q2.Getfront(fo, fa, fd, ft);
        if (ft < idle2) {
          int abortTime = idle2;
          int delay = abortTime - fa;
          AbortList.push_back(vector<int>{fo, 2, delay, abortTime});
          q2.Dequeue();
          continue;
        }
        int start = idle2;
        int finish = start + fd;
        if (finish > ft) {
          int delay = start - fa;
          TimeoutList.push_back(vector<int>{fo, 2, delay, finish});
        }
        idle2 = finish;
        q2.Dequeue();
      }

      // 決定要選哪位廚師 (SQF Case1..4)
      bool chef1_idle_and_empty = (idle1 <= arrival && q1.Getsize() == 0);
      bool chef2_idle_and_empty = (idle2 <= arrival && q2.Getsize() == 0);

      int chosenChef = -1;

      if (chef1_idle_and_empty && !chef2_idle_and_empty) chosenChef = 1;
      else if (chef2_idle_and_empty && !chef1_idle_and_empty) chosenChef = 2;
      else if (chef1_idle_and_empty && chef2_idle_and_empty) chosenChef = 1;
      else {
        bool q1_full = (q1.Getsize() >= 3);
        bool q2_full = (q2.Getsize() >= 3);

        if (!(q1_full && q2_full)) {
          if (q1.Getsize() <= q2.Getsize()) chosenChef = 1;
          else chosenChef = 2;
        } else {
          // both full => abort CID=0
          AbortList.push_back(vector<int>{oid, 0, 0, arrival});
          idx++;
          continue;
        }
      }

      // 如果選到 chef1
      if (chosenChef == 1) {
        if (q1.Getsize() == 0 && idle1 <= arrival) {
          int start = arrival;
          if (timeout < start) {
            int abortTime = start;
            int delay = abortTime - arrival;
            AbortList.push_back(vector<int>{oid, 1, delay, abortTime});
          } else {
            int finish = start + duration;
            if (finish > timeout) {
              int delay = start - arrival;
              TimeoutList.push_back(vector<int>{oid, 1, delay, finish});
            }
            idle1 = start + duration;
          }
        } else {
          q1.Enqueue(oid, arrival, duration, timeout);
        }
      } else { // chosenChef == 2
        if (q2.Getsize() == 0 && idle2 <= arrival) {
          int start = arrival;
          if (timeout < start) {
            int abortTime = start;
            int delay = abortTime - arrival;
            AbortList.push_back(vector<int>{oid, 2, delay, abortTime});
          } else {
            int finish = start + duration;
            if (finish > timeout) {
              int delay = start - arrival;
              TimeoutList.push_back(vector<int>{oid, 2, delay, finish});
            }
            idle2 = start + duration;
          }
        } else {
          q2.Enqueue(oid, arrival, duration, timeout);
        }
      }

      idx++;
    } // end arrivals

    // 處理剩餘 q1
    while (!q1.Isempty()) {
      int fo, fa, fd, ft;
      q1.Getfront(fo, fa, fd, ft);
      if (ft < idle1) {
        int abortTime = idle1;
        int delay = abortTime - fa;
        AbortList.push_back(vector<int>{fo, 1, delay, abortTime});
        q1.Dequeue();
        continue;
      }
      int start = idle1;
      int finish = start + fd;
      if (finish > ft) {
        int delay = start - fa;
        TimeoutList.push_back(vector<int>{fo, 1, delay, finish});
      }
      idle1 = finish;
      q1.Dequeue();
    }

    // 處理剩餘 q2
    while (!q2.Isempty()) {
      int fo, fa, fd, ft;
      q2.Getfront(fo, fa, fd, ft);
      if (ft < idle2) {
        int abortTime = idle2;
        int delay = abortTime - fa;
        AbortList.push_back(vector<int>{fo, 2, delay, abortTime});
        q2.Dequeue();
        continue;
      }
      int start = idle2;
      int finish = start + fd;
      if (finish > ft) {
        int delay = start - fa;
        TimeoutList.push_back(vector<int>{fo, 2, delay, finish});
      }
      idle2 = finish;
      q2.Dequeue();
    }

    // 計算總延誤與失敗比例
    long long totalDelay = 0;
    for (size_t i = 0; i < AbortList.size(); ++i) totalDelay += AbortList[i][2];
    for (size_t i = 0; i < TimeoutList.size(); ++i) totalDelay += TimeoutList[i][2];
    int failures = (int)AbortList.size() + (int)TimeoutList.size();
    double failurePercentage = 0.0;
    if (n > 0) {
      failurePercentage = (100.0 * failures) / n;
      // 四捨五入到小數點後兩位 (不使用 round 函數也可用)
      failurePercentage = floor(failurePercentage * 100.0 + 0.5) / 100.0;
    }

    // 寫檔
    ofstream fout(outfilename);
    if (!fout.is_open()) return;

    fout << "\t[Abort List]\n";
    fout << "\tOID\tCID\tDelay\tAbort\n";
    int cnt = 1;
    for (size_t i = 0; i < AbortList.size(); ++i) {
      fout << "[" << cnt << "]\t" << AbortList[i][0] << "\t" << AbortList[i][1] << "\t" << AbortList[i][2] << "\t" << AbortList[i][3] << "\n";
      ++cnt;
    }
    fout << "\t[Timeout List]\n";
    fout << "\tOID\tCID\tDelay\tDeparture\n";
    cnt = 1;
    for (size_t i = 0; i < TimeoutList.size(); ++i) {
      fout << "[" << cnt << "]\t" << TimeoutList[i][0] << "\t" << TimeoutList[i][1] << "\t" << TimeoutList[i][2] << "\t" << TimeoutList[i][3] << "\n";
      ++cnt;
    }

    fout << "[Total Delay]\n" << totalDelay << " min.\n";
    fout << "[Failure Percentage]\n" << fixed << setprecision(2) << failurePercentage << " %" << "\n";
    fout.close();
  }

// 任務四：多重佇列模擬 (Multiple N) — 不使用 auto
  void Multiple(int N, const string &outfilename) {
    if (N <= 0) return;
    int n = intdata.size();
    vector<Queue> queues;
    queues.resize(N);
    vector<int> idle;
    idle.resize(N);
    for (int i = 0; i < N; ++i) idle[i] = 0;

    int idx = 0;
    vector<vector<int>> AbortList;
    vector<vector<int>> TimeoutList;

    while (idx < n) {
      int oid = intdata[idx][0];
      int arrival = intdata[idx][1];
      int duration = intdata[idx][2];
      int timeout = intdata[idx][3];

      // 忽略不合法
      if (duration <= 0 || arrival + duration > timeout) {
        idx++;
        continue;
      }

      // 處理每個 chef 的隊列直到 idle > arrival
      for (int c = 0; c < N; ++c) {
        while (!queues[c].Isempty() && idle[c] <= arrival) {
          int fo, fa, fd, ft;
          queues[c].Getfront(fo, fa, fd, ft);
          if (ft < idle[c]) {
            int abortTime = idle[c];
            int delay = abortTime - fa;
            AbortList.push_back(vector<int>{fo, c+1, delay, abortTime});
            queues[c].Dequeue();
            continue;
          }
          int start = idle[c];
          int finish = start + fd;
          if (finish > ft) {
            int delay = start - fa;
            TimeoutList.push_back(vector<int>{fo, c+1, delay, finish});
          }
          idle[c] = finish;
          queues[c].Dequeue();
        }
      }

      // 找出 idle & empty 的 chefs
      vector<int> idle_empty;
      for (int c = 0; c < N; ++c) {
        if (idle[c] <= arrival && queues[c].Getsize() == 0) {
          idle_empty.push_back(c);
        }
      }

      int chosen = -1;
      if ((int)idle_empty.size() == 1) {
        chosen = idle_empty[0];
      } else if ((int)idle_empty.size() > 1) {
        chosen = idle_empty[0]; // 最小編號的 (idle_empty 已按順序)
      } else {
        // 找最短長度
        int best_len = 1000000000;
        for (int c = 0; c < N; ++c) {
          int len = queues[c].Getsize();
          if (len < best_len) best_len = len;
        }
        if (best_len >= 3) {
          // all full => abort CID 0
          AbortList.push_back(vector<int>{oid, 0, 0, arrival});
          idx++;
          continue;
        } else {
          // 選第一個長度為 best_len 的最小編號 chef
          for (int c = 0; c < N; ++c) {
            if (queues[c].Getsize() == best_len) {
              chosen = c;
              break;
            }
          }
        }
      }

      // 若 chosen 的 queue 為空且 idle <= arrival -> 直接處理
      if (queues[chosen].Getsize() == 0 && idle[chosen] <= arrival) {
        int start = arrival;
        if (timeout < start) {
          int abortTime = start;
          int delay = abortTime - arrival;
          AbortList.push_back(vector<int>{oid, chosen+1, delay, abortTime});
        } else {
          int finish = start + duration;
          if (finish > timeout) {
            int delay = start - arrival;
            TimeoutList.push_back(vector<int>{oid, chosen+1, delay, finish});
          }
          idle[chosen] = start + duration;
        }
      } else {
        queues[chosen].Enqueue(oid, arrival, duration, timeout);
      }

      idx++;
    } // end arrivals

    // 處理剩餘每個隊列
    for (int c = 0; c < N; ++c) {
      while (!queues[c].Isempty()) {
        int fo, fa, fd, ft;
        queues[c].Getfront(fo, fa, fd, ft);
        if (ft < idle[c]) {
          int abortTime = idle[c];
          int delay = abortTime - fa;
          AbortList.push_back(vector<int>{fo, c+1, delay, abortTime});
          queues[c].Dequeue();
          continue;
        }
        int start = idle[c];
        int finish = start + fd;
        if (finish > ft) {
          int delay = start - fa;
          TimeoutList.push_back(vector<int>{fo, c+1, delay, finish});
        }
        idle[c] = finish;
        queues[c].Dequeue();
      }
    }

    // totals
    long long totalDelay = 0;
    for (size_t i = 0; i < AbortList.size(); ++i) totalDelay += AbortList[i][2];
    for (size_t i = 0; i < TimeoutList.size(); ++i) totalDelay += TimeoutList[i][2];
    int failures = (int)AbortList.size() + (int)TimeoutList.size();
    double failurePercentage = 0.0;
    if (n > 0) {
      failurePercentage = (100.0 * failures) / n;
      failurePercentage = floor(failurePercentage * 100.0 + 0.5) / 100.0;
    }

    ofstream fout(outfilename);
    if (!fout.is_open()) return;

    fout << "\t[Abort List]\n";
    fout << "\tOID\tCID\tDelay\tAbort\n";
    int cnt = 1;
    for (size_t i = 0; i < AbortList.size(); ++i) {
      fout << "[" << cnt << "]\t" << AbortList[i][0] << "\t" << AbortList[i][1] << "\t" << AbortList[i][2] << "\t" << AbortList[i][3] << "\n";
      ++cnt;
    }
    fout << "\t[Timeout List]\n";
    fout << "\tOID\tCID\tDelay\tDeparture\n";
    cnt = 1;
    for (size_t i = 0; i < TimeoutList.size(); ++i) {
      fout << "[" << cnt << "]\t" << TimeoutList[i][0] << "\t" << TimeoutList[i][1] << "\t" << TimeoutList[i][2] << "\t" << TimeoutList[i][3] << "\n";
      ++cnt;
    }

    fout << "[Total Delay]\n" << totalDelay << " min.\n";
    fout << "[Failure Percentage]\n" << fixed << setprecision(2) << failurePercentage << " %" << "\n";
    fout.close();
  }
};



int main() {
  Data d;
  string filenumber;
  bool command2 = false;
  while (1) {
    cout << "*** (^_^) Data Structure (^o^) ***" << endl;
    cout << "** Simulate FIFO Queues by SQF ***" << endl;
    cout << "* 0. Quit                        *" << endl;
    cout << "* 1. Sort a file                 *" << endl;
    cout << "* 2. Simulate one FIFO queue     *" << endl;
    cout << "* 3. Simulate two queues by SQF  *" << endl;
    cout << "* 4. Simulate some queues by SQF *" << endl;
    cout << "**********************************" << endl;
    string command;
    cout << "Input a command(0, 1, 2, 3, 4): ";
    cin >> command;

    if (command == "1") {
      d.Clean();
      cout << "\nInput a file number (e.g., 401, 402, 403, ...): ";
      cin >> filenumber;
      cout << endl;
      string filename = "input" + filenumber + ".txt";
      double readtime = d.Read(filename);

      if (readtime == -1) {
        continue;
      }

      d.Print();
      cout << endl;

      d.Stringtoint();
      double sorttime = d.shellSort();

      string sortfilename = "sorted" + filenumber + ".txt";
      double writetime = d.WriteFile(sortfilename);

      cout << "Reading data: " << readtime << " us." << endl;
      cout << endl;
      cout << "Sorting data: " << sorttime << " us." << endl;
      cout << endl;
      cout << "Writing data: " << writetime << " us." << endl;
      cout << endl;
      command2 = false;
    } else if (command == "2") {
      d.Clean();
      cout << "\nInput a file number (e.g., 401, 402, 403, ...): ";
      cin >> filenumber;
      cout << endl;
      string filename = "sorted" + filenumber + ".txt";
      
      if (d.Read(filename) == -1) {
        continue;
      }

      d.Stringtoint();
      d.Print();
      cout << endl;
      string onefilename = "one" + filenumber + ".txt";
      d.One(onefilename);
      command2 = true;
    } else if (command == "3") {
      cout << endl;
      if (command2) {
        string onefilename = "two" + filenumber + ".txt";
        d.Two(onefilename);
      } else {
        cout << "### Execute command 2 first! ###" << endl;
        cout << endl;
      }
    } else if (command == "4") {
      cout << endl;
      if (command2) {
        int number;
        cout << "Input the number of queues: ";
        cin >> number;
        cout << endl;
        string anyfilename = "any" + filenumber + ".txt";
        d.Multiple(number, anyfilename);
      } else {
        cout << "### Execute command 2 first! ###" << endl;
        cout << endl;
      }
    } else if (command == "0") {
      break;
    } else {
      cout << "\nCommand does not exist!" << endl;
      cout << endl;
    }
  }
  return 0;
}
