// 11327207 呂強 & 11327209 鄭育昇
#include <iostream>
#include <fstream>
#include <sstream>
#include <string>
#include <vector>
#include <ctime>
#include <iomanip>
using namespace std;

struct Node {
  int oid;
  int arrival;
  int duration;
  int timeout;
  Node *next;
};

class Queue {
 private:
   Node * backptr {nullptr};
   Node * frontptr {nullptr};
   int size = 0;
 public:
  bool Isempty() {
    if (backptr == nullptr) {
      return true;
    }
    return false;
  }

  void Enqueue(int o, int a, int d, int t) {
    Node *newptr = new Node;
    newptr->oid = o;
    newptr->arrival = a;
    newptr->duration = d;
    newptr->timeout = t;
    newptr->next = nullptr;

    if (Isempty()) {
      frontptr = newptr;
    } else {
      backptr->next = newptr;
    }
    backptr = newptr;
    size++;
  }

  void Dequeue() {
    if (Isempty()) {
      return;
    }
    Node *temp = frontptr;
    if (frontptr == backptr) {
      frontptr = nullptr;
      backptr = nullptr;
    } else {
      frontptr = frontptr->next;
    }
    temp->next = nullptr;
    delete temp;
    size--;
  }

  int Getsize() {
    return size;
  }

  void Getfront(int &o, int &a, int &d, int &t) {
    if (Isempty()) {
      return;
    }
    o = frontptr->oid;
    a = frontptr->arrival;
    d = frontptr->duration;
    t = frontptr->timeout;
  }
};



class Data {
 private:
  int column = 0;
  int row = 0;
  vector<vector<string>> data;
  vector<vector<int>> intdata;
 public:
  double Read(string filename) {
    clock_t start, end;
    start = clock();

    ifstream fin(filename);
    if (!fin.is_open()) {
      cout << "### "<< filename << " does not exist! ###\n\n";
      return -1;
    }
    string line;
    while (getline(fin, line)) {
      if (line.empty()) continue; // 跳過空行

      stringstream ss(line);
      string value;
      vector<string> row;
      while (ss >> value) {
        row.push_back(value);
      }
      data.push_back(row);
     }
    end = clock();
    double time = double(end - start) / CLOCKS_PER_SEC * 1'000'000;;
    fin.close();
    return time;
  }

  void Print() {
    cout << "\t";
    if (data[0][0] != "OID" || data[0][0] == "OID") {
      cout << "OID\t";
    }
    if (data[0][1] != "Arrival" || data[0][1] == "Arrival") {
      cout << "Arrival\t";
    }
    if (data[0][2] != "Duration" || data[0][2] == "Duration") {
      cout << "Duration\t";
    }
    if (data[0][3] != "TimeOut" || data[0][3] == "TimeOut") {
      cout << "TimeOut\n";
    }
    for (int i = 1; i < data.size(); i++) {
      if (i < data.size()) {
        cout << "(" << i << ") \t";
      }
      for (int j = 0; j < data[i].size(); j++) {
        if (j <= 2) {
          cout << data[i][j] << "\t";
        } else {
          cout << data[i][j];
        }
      }
       cout << endl;
    }
  }

  void Stringtoint() {
    intdata.resize(data.size()-1);
    for (int i = 1; i < data.size(); i++) {
      intdata[i-1].resize(data[i].size());
      for (int j = 0; j < data[i].size(); j++) {
        intdata[i-1][j] = stoi(data[i][j]);
      }
    }
  }

  double shellSort() {
    clock_t start, end;
    start = clock();
    int n = intdata.size();
    for (int h = intdata.size()/2; h > 0; h = h/2) {
      for (int unsorted = h; unsorted < n; ++unsorted) {
        vector<int> temp = intdata[unsorted];
        int j = unsorted;
        while (j >= h && intdata[j - h][1] >= temp[1]) {
          if (intdata[j-h][1] == temp[1]) {
            if (intdata[j-h][0] > temp[0]) {
              intdata[j] = intdata[j - h];
            } else {
              j -= h;
              continue;
            }
          } else {
            intdata[j] = intdata[j - h];   // 移動整行
          }
          j -= h;
          intdata[j] = temp;
        }
      }
    }
    end = clock();
    double time = double(end - start) / CLOCKS_PER_SEC * 1'000'000;;
    return time;
  }

  double WriteFile(string filename) {
    clock_t start, end;
    start = clock();
    ofstream fout(filename);

    if (!fout.is_open()) {
      cout << "Cannot open file!" << endl;
      return -1;
    }
    fout << "OID\tArrival\tDuration\tTimeOut" << endl;
    for (int i = 0; i < intdata.size(); i++) {
      for (int j = 0; j < intdata[i].size(); j++) {
        fout << intdata[i][j];
        if (j != intdata[i].size() - 1) fout << "\t"; // 每個數字用空格隔開
      }
      fout << "\n"; // 換行
    }
    end = clock();
    double time = double(end - start) / CLOCKS_PER_SEC * 1'000'000;;
    fout.close();
    return time;
  }

  void Clean() {
    data.clear();
    intdata.clear();
  }

  void One(string filename) {
    Queue q;
    ofstream fout(filename);
    if (!fout.is_open()) {
      cout << "Cannot open file!" << endl; return;
    }

    int n = intdata.size();

    int index = 0;
    int idleTime = 0; // 廚師閒置時間

    vector<vector<int>> AbortList;    // {OID, CID, Delay, Abort}
    vector<vector<int>> TimeoutList;  // {OID, CID, Delay, Departure}

    int done = 0;
    int illegal = 0;
    while (index < n || !q.Isempty()) {
        // 處理 Chef 1佇列 
      while (!q.Isempty() && (
            (index < n && intdata[index][1] >= idleTime) ||  // 有新訂單且新訂單的arrival >= 閒置時間
            (index >= n))){  // 沒有新訂單
        int oid, arr, dur, tol;
        q.Getfront(oid, arr, dur, tol);
        if (idleTime > tol) {  // 閒置時間 > 逾時時間 -> 取消訂單
          q.Dequeue(); 
          int delay = idleTime - arr;
          AbortList.push_back({oid, 1, delay, idleTime});
          continue;
        }
        if (index >= n || intdata[index][1] >= idleTime) {  // 沒有新訂單或新訂單的arrival >= 閒置時間
          q.Dequeue();
          int startTime;
          if (idleTime > arr) {  // 閒置時間 > 抵達時間
            startTime = idleTime;  // 開始時間 = 閒置時間
          } else {
            startTime = arr;  // 開始時間 = 抵達時間
          }
          int finishTime = startTime + dur;  
          idleTime = finishTime;
          if (finishTime > tol) {  // 結束時間 > 逾時時間 -> 放入逾時清單
            int delay = startTime - arr;
            TimeoutList.push_back({oid, 1, delay, finishTime});
          } 
          done++;
        } else {
          break;
        }
      }


    // 處理新訂單
    if (index < n) {
      int oid = intdata[index][0];
      int arr = intdata[index][1];
      int dur = intdata[index][2];
      int tol = intdata[index][3];

      if (arr + dur > tol || dur <= 0 || arr < 0 || tol < 0 || oid < 0) {  // 為不合法訂單
        index++;
        illegal++;
        continue;
      }

      // 先找 idle 且空佇列
      if (idleTime <= arr && q.Isempty()) {
        int startTime = arr;
        int finishTime = startTime + dur;
        idleTime = finishTime; 
        if (finishTime > tol) {  // 結束時間 > 逾時時間 -> 放入逾時清單
          int delay = startTime - arr;
          TimeoutList.push_back({oid, 1, delay, (int)finishTime});
        } 
        done++;  //-> direct start
      }  else {
        if (q.Getsize() < 3) {
          q.Enqueue(oid, arr, dur, tol);  // -> inqueue
        }  else {
          AbortList.push_back({oid, 0, 0, arr});  // -> abort (佇列已滿)
        }
      }
      index++;
    }
  }
    // 輸出結果
    fout << "\t[Abort List]\n\tOID\tCID\tDelay\tAbort\n";
    int i = 1;
    for (int j = 0; j < AbortList.size(); j++) {
     fout << "[" << i << "]\t"
          << AbortList[j][0] << "\t"
          << AbortList[j][1] << "\t"
          << AbortList[j][2] << "\t"
          << AbortList[j][3] << "\n";
      i++;
    }
    i = 1;
    fout << "\t[Timeout List]\n\tOID\tCID\tDelay\tDeparture\n";
    for (int j = 0; j < TimeoutList.size(); j++) {
      fout << "[" << i << "]\t"
          << TimeoutList[j][0] << "\t"
          << TimeoutList[j][1] << "\t"
          << TimeoutList[j][2] << "\t"
          << TimeoutList[j][3] << "\n";
      i++;
    }
    int totalDelay = 0;
    for (int i = 0; i < AbortList.size(); i++) {
      totalDelay += AbortList[i][2];
    }

    for (int i = 0; i < TimeoutList.size(); i++) {
      totalDelay += TimeoutList[i][2];
    }
    fout << "[Total Delay]\n" << totalDelay << " min.\n";

    double failurePercentage = (double)(AbortList.size() + TimeoutList.size())/ (n-illegal) * 100.0;
    fout << "[Failure Percentage]\n" << fixed << setprecision(2) << failurePercentage << " %\n";
  }

  void Two(string filename) {
    Queue qA, qB;
    ofstream fout(filename);
    if (!fout.is_open()) {
      cout << "Cannot open file!" << endl; return;
    }

    int n = intdata.size();

    int index = 0;
    int idleTimeA = 0, idleTimeB = 0; // 廚師閒置時間

    vector<vector<int>> AbortList;    // {OID, CID, Delay, Abort}
    vector<vector<int>> TimeoutList;  // {OID, CID, Delay, Departure}

    int doneA = 0, doneB = 0;
    int illegal = 0;
    while (index < n || !qA.Isempty() || !qB.Isempty()) {
        // 處理 Chef A 佇列 
      while (!qA.Isempty() && (
            (index < n && intdata[index][1] >= idleTimeA) ||  // 有新訂單且新訂單的arrival >= 閒置時間
            (index >= n && (idleTimeA <= idleTimeB || qB.Isempty())))){  // 沒有新訂單且A的閒置時間 <= B的閒置時間或者B佇列是空的
        int oid, arr, dur, tol;
        qA.Getfront(oid, arr, dur, tol);
        if (idleTimeA > tol) {  // 閒置時間 > 逾時時間 -> 取消訂單
          qA.Dequeue(); 
          int delay = idleTimeA - arr;
          AbortList.push_back({oid, 1, delay, idleTimeA});
          continue;
        }
        if (index >= n || intdata[index][1] >= idleTimeA) {  // 沒有新訂單或新訂單的arrival >= 閒置時間
          qA.Dequeue();
          int startTime;
          if (idleTimeA > arr) {  // 閒置時間 > 抵達時間
            startTime = idleTimeA;  // 開始時間 = 閒置時間
          } else {
            startTime = arr;  // 開始時間 = 抵達時間
          }
          int finishTime = startTime + dur;  
          idleTimeA = finishTime;
          if (finishTime > tol) {  // 結束時間 > 逾時時間 -> 放入逾時清單
            int delay = startTime - arr;
            TimeoutList.push_back({oid, 1, delay, finishTime});
          } 
          doneA++;
        } else {
          break;
        }
      }
        // 處理 Chef B 佇列 
    while (!qB.Isempty() && (
          (index < n && intdata[index][1] >= idleTimeB) ||  // 有新訂單且新訂單的arrival >= 閒置時間
          (index >= n && (idleTimeB < idleTimeA || qA.Isempty())))){  // 沒有新訂單且B的閒置時間 < A的閒置時間或者A佇列是空的

      int oid, arr, dur, tol;
      qB.Getfront(oid, arr, dur, tol);
      if (idleTimeB > tol) {  // 閒置時間 > 逾時時間 -> 取消訂單
        qB.Dequeue();
        int delay = idleTimeB - arr;
        AbortList.push_back({oid, 2, delay, idleTimeB});
        continue;
      }
      if (index >= n || intdata[index][1] >= idleTimeB) {  // 沒有新訂單或新訂單的arrival >= 閒置時間
        qB.Dequeue();
        int startTime;
        if (idleTimeB > arr) {  // 閒置時間 > 抵達時間
          startTime = idleTimeB;  // 開始時間 = 閒置時間
        } else {
          startTime = arr;  // 開始時間 = 抵達時間
        }
        int finishTime = startTime + dur;
        idleTimeB = finishTime;
        if (finishTime > tol) {  // 結束時間 > 逾時時間 -> 放入逾時清單
        int delay = startTime - arr;
        TimeoutList.push_back({oid, 2, delay, finishTime});
        } 
        doneB++;
      } else {
        break;
      }
    }

    // 處理新訂單
    if (index < n) {
      int oid = intdata[index][0];
      int arr = intdata[index][1];
      int dur = intdata[index][2];
      int tol = intdata[index][3];

      if (arr + dur > tol || dur <= 0 || arr < 0 || tol < 0 || oid < 0) {  // 為不合法訂單
        index++;
        illegal++;
        continue;
      }

      // 先找 idle 且空佇列
      if (idleTimeA <= arr && qA.Isempty()) {
        int startTime = arr;
        int finishTime = startTime + dur;
        idleTimeA = finishTime; 
        if (finishTime > tol) {  // 結束時間 > 逾時時間 -> 放入逾時清單
          int delay = startTime - arr;
          TimeoutList.push_back({oid, 1, delay, (int)finishTime});
        } 
        doneA++;  //-> direct start (Chef 1)
      } else if (idleTimeB <= arr && qB.Isempty()) {
        int startTime = arr;
        int finishTime = startTime + dur;
        idleTimeB = finishTime;
        if (finishTime > tol) {  // 結束時間 > 逾時時間 -> 放入逾時清單
          int delay = startTime - arr;
          TimeoutList.push_back({oid, 2, delay, finishTime});
        } 
        doneB++;  //-> direct start (Chef 2)
      } else {
        if (qA.Getsize() <= qB.Getsize() && qA.Getsize() < 3) {
          qA.Enqueue(oid, arr, dur, tol);  // -> inqueue (Chef 1)
        } else if (qB.Getsize() < 3) {
          qB.Enqueue(oid, arr, dur, tol);  // -> inqueue (Chef 2)
        } else {
          AbortList.push_back({oid, 0, 0, arr});  // -> abort (佇列已滿)
        }
      }

      index++;
    }
  }
    // 輸出結果
    fout << "\t[Abort List]\n\tOID\tCID\tDelay\tAbort\n";
    int i = 1;
    for (int j = 0; j < AbortList.size(); j++) {
     fout << "[" << i << "]\t"
          << AbortList[j][0] << "\t"
          << AbortList[j][1] << "\t"
          << AbortList[j][2] << "\t"
          << AbortList[j][3] << "\n";
      i++;
    }
    i = 1;
    fout << "\t[Timeout List]\n\tOID\tCID\tDelay\tDeparture\n";
    for (int j = 0; j < TimeoutList.size(); j++) {
      fout << "[" << i << "]\t"
          << TimeoutList[j][0] << "\t"
          << TimeoutList[j][1] << "\t"
          << TimeoutList[j][2] << "\t"
          << TimeoutList[j][3] << "\n";
      i++;
    }
    int totalDelay = 0;
    for (int i = 0; i < AbortList.size(); i++) {
      totalDelay += AbortList[i][2];
    }

    for (int i = 0; i < TimeoutList.size(); i++) {
      totalDelay += TimeoutList[i][2];
    }
    fout << "[Total Delay]\n" << totalDelay << " min.\n";

    double failurePercentage = (double)(AbortList.size() + TimeoutList.size())/ (n-illegal) * 100.0;
    fout << "[Failure Percentage]\n" << fixed << setprecision(2) << failurePercentage << " %\n";
  }


  void Multiple(int numChefs, string filename) {
    vector<Queue> q(numChefs);                // 多個佇列
    vector<int> idleTime(numChefs, 0);  // 多個閒置時間

    ofstream fout(filename);
    if (!fout.is_open()) {
      cout << "Cannot open file!"; return;
    }

    int n = intdata.size();
    int index = 0;

    vector<vector<int>> AbortList;    // {OID, CID, Delay, Abort}
    vector<vector<int>> TimeoutList;  // {OID, CID, Delay, Departure}

    vector<int> done(numChefs, 0);
    int illegal = 0;
    bool hasNotEmpty = false;
    while (index < n || hasNotEmpty) {
      hasNotEmpty = false;
      for (int i = 0; i < q.size(); i++) {  //判斷是否還有任何佇列未清空
        if (!q[i].Isempty()) {
          hasNotEmpty = true;
          break;
        }
      }

        // 先處理所有廚師佇列的訂單
      for (int c = 0; c < numChefs; c++) {
        while (!q[c].Isempty() && (index >= n || intdata[index][1] >= idleTime[c])) {
          int oid, arr, dur, tol;
          q[c].Getfront(oid, arr, dur, tol);

          // abort 檢查
          if (idleTime[c] > tol) {  // 閒置時間 > 逾時時間 -> 取消訂單
            q[c].Dequeue();
            int delay = idleTime[c] - arr;
            AbortList.push_back({oid, c+1, delay, idleTime[c]});
            continue;
          }

          // 如果還有新訂單，且新訂單的 arrival < idleTime → stop
          if (index < n && intdata[index][1] < idleTime[c])
            break;

          // 可以開始烹飪
          q[c].Dequeue();
          int startTime;
          if (idleTime[c] > arr) {
            startTime = idleTime[c];
          } else {
            startTime = arr;
          }
          int finishTime = startTime + dur;

          idleTime[c] = finishTime;
          int delay = startTime - arr;

          if (finishTime > tol)  // 結束時間 > 逾時時間 -> 放入逾時清單
            TimeoutList.push_back({oid, c+1, delay, finishTime});

          done[c]++;
        }
      }

        // 沒有新訂單就跳迴圈
      if (index >= n) continue;

        // 處理新訂單
      int oid = intdata[index][0];
      int arr = intdata[index][1];
      int dur = intdata[index][2];
      int tol = intdata[index][3];

        // 1. 找 idle & empty
      if (arr + dur > tol || dur <= 0 || arr < 0 || tol < 0 || oid < 0) {  // 為不合法訂單
        index++;
        illegal++;
        continue;
      }
      bool assigned = false;
      for (int c = 0; c < numChefs; c++) {
        if (idleTime[c] <= arr && q[c].Isempty()) {
          int startTime = arr;
          int finishTime = startTime + dur;
          idleTime[c] = finishTime;

          int delay = startTime - arr;
          if (finishTime > tol) // 結束時間 > 逾時時間 -> 放入逾時清單
            TimeoutList.push_back({oid, c+1, delay, finishTime});
          done[c]++;
          assigned = true;
          break;
        }
      }

        // 2. 最短佇列 (<3)
      if (!assigned) {
        int bestChef = -1;
        int bestSize = 10;  // 預設值

        for (int c = 0; c < numChefs; c++) {
          if (q[c].Getsize() < 3 && q[c].Getsize() < bestSize) {
            bestSize = q[c].Getsize();  // 每次遇到比 bestSize 還短的佇列，就更新bestSize
            bestChef = c; 
          }
        }

        if (bestChef != -1) {
          q[bestChef].Enqueue(oid, arr, dur, tol);
          assigned = true;
        }
      }

        // 3. 佇列都滿了 → abort
      if (!assigned) {
        AbortList.push_back({oid, 0, 0, arr});
      }

      index++;
    }
    // 輸出結果
    fout << "\t[Abort List]\n\tOID\tCID\tDelay\tAbort\n";
    int i = 1;
    for (int j = 0; j < AbortList.size(); j++) {
      fout << "[" << i << "]\t"
           << AbortList[j][0] << "\t"
           << AbortList[j][1] << "\t"
           << AbortList[j][2] << "\t"
           << AbortList[j][3] << "\n";
      i++;
    }

    fout << "\t[Timeout List]\n\tOID\tCID\tDelay\tDeparture\n";
    i = 1;
    for (int j = 0; j < TimeoutList.size(); j++) {
      fout << "[" << i << "]\t"
           << TimeoutList[j][0] << "\t"
           << TimeoutList[j][1] << "\t"
           << TimeoutList[j][2] << "\t"
           << TimeoutList[j][3] << "\n";
      i++;
    }

    int totalDelaySum = 0;
    for (int i = 0; i < AbortList.size(); i++) {
      totalDelaySum += AbortList[i][2];
     }

    for (int i = 0; i < TimeoutList.size(); i++) {
      totalDelaySum += TimeoutList[i][2];
    }

    fout << "[Total Delay]\n" << totalDelaySum << " min.\n";

    double failurePercentage = (double)(AbortList.size() + TimeoutList.size()) / (n-illegal) * 100.0;
    fout << fixed << setprecision(2);
    fout << "[Failure Percentage]\n" << failurePercentage << " %\n";
  }

};


int main() {
  Data d;
  string filenumber;
  bool command2 = false;
  while (1) {
    cout << "*** (^_^) Data Structure (^o^) ***" << endl;
    cout << "** Simulate FIFO Queues by SQF ***" << endl;
    cout << "* 0. Quit                        *" << endl;
    cout << "* 1. Sort a file                 *" << endl;
    cout << "* 2. Simulate one FIFO queue     *" << endl;
    cout << "* 3. Simulate two queues by SQF  *" << endl;
    cout << "* 4. Simulate some queues by SQF *" << endl;
    cout << "**********************************" << endl;
    int command;
    cout << "Input a command(0, 1, 2, 3, 4): ";
    cin >> command;
    if (command == 1) {
      d.Clean();
      cout << "\nInput a file number (e.g., 401, 402, 403, ...): ";
      cin >> filenumber;
      cout << endl;
      string filename = "input" + filenumber + ".txt";
      double readtime = d.Read(filename);
      if (readtime == -1) {
        continue;
      }
      d.Print();
      cout << endl;

      d.Stringtoint();
      double sorttime = d.shellSort();

      string sortfilename = "sorted" + filenumber + ".txt";
      double writetime = d.WriteFile(sortfilename);

      cout << "Reading data: " << readtime << " us." << endl;
      cout << endl;
      cout << "Sorting data: " << sorttime << " us." << endl;
      cout << endl;
      cout << "Writing data: " << writetime << " us." << endl;
      cout << endl;
      command2 = false;
    } else if (command == 2) {
      d.Clean();
      cout << "\nInput a file number (e.g., 401, 402, 403, ...): ";
      cin >> filenumber;
      cout << endl;
      string filename = "sorted" + filenumber + ".txt";
      double readtime = d.Read(filename);
      if (readtime == -1) {
        continue;
      }
      d.Stringtoint();
      d.Print();
      cout << endl;
      string onefilename = "one" + filenumber + ".txt";
      d.One(onefilename);
      command2 = true;
    } else if (command == 3) {
      cout << endl;
      if (command2) {
        string onefilename = "two" + filenumber + ".txt";
        d.Two(onefilename);
      } else {
        cout << "### Execute command 2 first! ###" << endl;
        cout << endl;
      }
    } else if (command == 4) {
      cout << endl;
      if (command2) {
        int number;
        cout << "Input the number of queues: ";
        cin >> number;
        cout << endl;
        if (number == 1) {
          string onefilename = "one" + filenumber + ".txt";
          d.One(onefilename);
        }
        if (number == 2) {
          string twofilename = "two" + filenumber + ".txt";
          d.Two(twofilename);
        } else {
          string anyfilename = "any" + filenumber + ".txt";
          d.Multiple(number, anyfilename);
        }
      } else {
        cout << "### Execute command 2 first! ###" << endl;
        cout << endl;
      }
    } else if (command == 0) {
      break;
    } else {
      cout << "\nCommand does not exist!" << endl;
      cout << endl;
    }
  }
  return 0;
}
